# ===========================================================================
# docker-compose.prod.yml — Production multi-container orchestration
# ===========================================================================
# Docker Compose defines and runs multiple containers as a single "stack".
# This file describes 4 services that work together:
#   web   → Django app (served by Gunicorn)
#   db    → MySQL 8.0 database
#   nginx → Reverse proxy and static file server
#   redis → In-memory cache (for future Celery task queue)
#
# Usage:
#   docker compose -f docker-compose.prod.yml build
#   docker compose -f docker-compose.prod.yml up -d
# ===========================================================================

services:

  # -------------------------------------------------------------------------
  # WEB — The Django application container
  # -------------------------------------------------------------------------
  web:
    build:
      context: .                                    # Build from the project root (where Dockerfile lives)
      dockerfile: Dockerfile                        # Use the main Dockerfile
      args:
        REQUIREMENTS_FILE: requirements/production.txt  # Install production dependencies (includes gunicorn)
    container_name: chic_transfer_api               # Fixed name for easy reference in logs/commands
    command: ["/app/docker/entrypoint.prod.sh"]     # Override CMD — run our production entrypoint script
    env_file:
      - .env.prod                                   # Load environment variables from .env.prod file
    volumes:
      # Named volumes share data between containers. These are NOT bind mounts
      # of your source code — the code is baked into the image via COPY in Dockerfile.
      - static_files:/app/staticfiles               # collectstatic output → shared with nginx
      - media_files:/app/media                      # User uploads → shared with nginx
    expose:
      - "8000"                                      # Expose port 8000 ONLY within the Docker network (not to host)
                                                    # nginx connects to this internally; users never hit 8000 directly
    restart: unless-stopped                         # Auto-restart on crash, but not if manually stopped
    depends_on:
      db:
        condition: service_healthy                  # Wait until MySQL passes its healthcheck before starting

  # -------------------------------------------------------------------------
  # DB — MySQL 8.0 database
  # -------------------------------------------------------------------------
  db:
    image: mysql:8.0                                # Official MySQL 8.0 image from Docker Hub
    container_name: chic_transfer_db
    restart: always                                 # Always restart — DB should never be down
    environment:
      # These env vars are read by the MySQL image on first start to create the database and user.
      MYSQL_DATABASE: ${DB_NAME:-chic_transfer_prod}    # Create this database on first run
      MYSQL_USER: ${DB_USER:-chic_user}                 # Create this user (non-root)
      MYSQL_PASSWORD: ${DB_PASSWORD:-chic_password}     # Password for MYSQL_USER
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD:-rootpassword}  # Root password (required by MySQL image)
    volumes:
      - mysql_data:/var/lib/mysql                   # Persist database files across container restarts
    healthcheck:
      # Docker runs this command periodically to check if MySQL is ready.
      # Other services with "depends_on: condition: service_healthy" wait for this.
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s                                 # Check every 10 seconds
      timeout: 5s                                   # Fail if no response in 5 seconds
      retries: 5                                    # Mark unhealthy after 5 consecutive failures
    ports:
      - "3306:3306"                                 # Expose MySQL to host (for external DB tools)

  # -------------------------------------------------------------------------
  # NGINX — Reverse proxy, SSL termination, and static file server
  # -------------------------------------------------------------------------
  nginx:
    image: nginx:1.25-alpine                        # Lightweight nginx image (~23MB)
    container_name: chic_transfer_nginx
    restart: always
    ports:
      - "80:80"                                     # HTTP  — redirects to HTTPS
      - "443:443"                                   # HTTPS — main entry point for users
    volumes:
      # Mount our custom nginx config into the container (read-only)
      - ./docker/nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro
      # Mount static & media volumes so nginx can serve them directly (bypassing Django)
      - static_files:/app/staticfiles:ro
      - media_files:/app/media:ro
      # Mount SSL certificates
      - ssl_certs:/etc/ssl/certs:ro
    depends_on:
      - web                                         # Start after web so the upstream is available

  # -------------------------------------------------------------------------
  # REDIS — In-memory data store
  # -------------------------------------------------------------------------
  redis:
    image: redis:7-alpine                           # Lightweight Redis image
    container_name: chic_transfer_redis
    restart: always
    volumes:
      - redis_data:/data                            # Persist Redis data (RDB snapshots)

# ---------------------------------------------------------------------------
# NAMED VOLUMES — Persistent storage managed by Docker
# ---------------------------------------------------------------------------
# Named volumes survive container rebuilds and restarts.
# Data is stored in /var/lib/docker/volumes/ on the host.
volumes:
  mysql_data:       # Database files — CRITICAL, never delete without a backup
  static_files:     # Django collectstatic output (CSS, JS, images from apps)
  media_files:      # User-uploaded files (KYC documents, profile photos, etc.)
  ssl_certs:        # SSL certificate files (fullchain.pem + privkey.pem)
  redis_data:       # Redis persistence data

networks:
  awdpay_network:
    external: true
