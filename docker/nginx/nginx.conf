# ===========================================================================
# Nginx Configuration — Reverse Proxy for Django
# ===========================================================================
# Nginx sits in front of Django/Gunicorn and handles:
#   1. SSL termination (HTTPS encryption/decryption)
#   2. Serving static files directly (CSS, JS, images) — much faster than Django
#   3. Serving media files directly (user uploads)
#   4. HTTP → HTTPS redirect
#   5. Security headers
#   6. Gzip compression (reduces bandwidth usage)
#
# Request flow: Client → Nginx (port 443) → Gunicorn (port 8000) → Django
# ===========================================================================

# "upstream" defines a group of backend servers that nginx can proxy to.
# Here we have one server: the Django container, reachable at hostname "web"
# (Docker Compose creates a DNS entry for each service name).
upstream django {
    server web:8000;    # "web" resolves to the Django container's IP inside Docker network
}

# ---------------------------------------------------------------------------
# Server Block 1: HTTP (port 80) → Redirect to HTTPS
# ---------------------------------------------------------------------------
# Anyone hitting http://yourdomain.com gets redirected to https://yourdomain.com
server {
    listen 80;          # Listen for HTTP connections on port 80
    server_name _;      # "_" means match ANY hostname (catch-all)

    # Exception: Let's Encrypt needs to reach /.well-known/acme-challenge/
    # over HTTP to verify domain ownership when renewing SSL certs.
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }

    # Everything else: redirect to HTTPS (301 = permanent redirect)
    location / {
        return 301 https://$host$request_uri;
        # $host     = the domain from the request (e.g., api.yourdomain.com)
        # $request_uri = the path + query string (e.g., /api/users/?page=2)
    }
}

# ---------------------------------------------------------------------------
# Server Block 2: HTTPS (port 443) — Main server
# ---------------------------------------------------------------------------
server {
    listen 443 ssl;     # Listen for HTTPS connections (SSL/TLS encrypted)
    server_name _;

    # --- SSL Certificate Paths ---
    # These files come from Let's Encrypt (via certbot) and are mounted
    # into the container via the ssl_certs Docker volume.
    ssl_certificate /etc/ssl/certs/fullchain.pem;       # Public certificate + chain
    ssl_certificate_key /etc/ssl/certs/privkey.pem;     # Private key (never share this!)

    # --- SSL Protocol Settings ---
    ssl_protocols TLSv1.2 TLSv1.3;     # Only allow modern TLS versions (disable old, insecure SSLv3/TLSv1.0/1.1)
    ssl_ciphers HIGH:!aNULL:!MD5;       # Use strong encryption ciphers, exclude weak ones
    ssl_prefer_server_ciphers on;        # Server chooses the cipher (prevents client from picking a weak one)
    ssl_session_cache shared:SSL:10m;    # Cache SSL sessions for 10 minutes (avoids re-handshake = faster)
    ssl_session_timeout 10m;

    # --- Request Size Limit ---
    # Maximum allowed size of the request body (file uploads, JSON payloads).
    # 10M = 10 megabytes. Requests larger than this get a 413 error.
    # Adjust based on your app's needs (e.g., KYC document uploads).
    client_max_body_size 10M;

    # --- Gzip Compression ---
    # Compress responses before sending to the client. Reduces bandwidth by 60-80%.
    gzip on;                        # Enable gzip
    gzip_vary on;                   # Tell proxies to cache compressed and uncompressed versions
    gzip_proxied any;               # Compress responses from proxied requests too
    gzip_comp_level 6;              # Compression level 1-9 (6 is a good speed/ratio balance)
    gzip_types                      # Only compress these MIME types (images are already compressed)
        text/plain
        text/css
        application/json
        application/javascript
        text/xml
        application/xml;

    # --- Security Headers ---
    # These headers protect against common web attacks.
    add_header X-Frame-Options "DENY" always;                   # Prevent clickjacking (no iframes)
    add_header X-Content-Type-Options "nosniff" always;         # Prevent MIME-type sniffing attacks
    add_header X-XSS-Protection "1; mode=block" always;         # Enable browser XSS filter
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;  # Control referrer info leakage
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;  # Force HTTPS for 1 year

    # --- Static Files ---
    # Serve static files (CSS, JS, admin assets) directly from nginx.
    # These were collected by "python manage.py collectstatic" into /app/staticfiles.
    # Nginx serves files ~10x faster than Django because it doesn't invoke Python.
    location /static/ {
        alias /app/staticfiles/;                    # Map /static/ URL to this directory
        expires 30d;                                # Browser caches for 30 days
        add_header Cache-Control "public, immutable";  # Tell browsers this file won't change
    }

    # --- Media Files ---
    # Serve user-uploaded files (profile photos, KYC documents, etc.)
    location /media/ {
        alias /app/media/;
        expires 7d;                                 # Shorter cache — uploads can be updated
        add_header Cache-Control "public";
    }

    # --- Proxy to Django ---
    # All other requests get forwarded to the Django/Gunicorn backend.
    location / {
        proxy_pass http://django;                   # Forward to the upstream block defined above
        proxy_set_header Host $host;                # Pass the original hostname to Django
        proxy_set_header X-Real-IP $remote_addr;    # Pass the client's real IP (not nginx's)
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  # Chain of proxy IPs
        proxy_set_header X-Forwarded-Proto $scheme; # Tell Django whether the request was HTTP or HTTPS
                                                    # Django reads this via SECURE_PROXY_SSL_HEADER setting
        proxy_redirect off;                         # Don't rewrite redirect URLs
        proxy_connect_timeout 300s;                 # Timeout waiting for backend to accept connection
        proxy_read_timeout 300s;                    # Timeout waiting for backend response
    }
}
